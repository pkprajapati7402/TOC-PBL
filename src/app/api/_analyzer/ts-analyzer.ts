import { JisonParser, JisonParserApi, StateType, SymbolsType, TerminalsType, ProductionsType } from '@ts-jison/parser';
/**
 * parser generated by  @ts-jison/parser-generator 0.4.1-alpha.2
 * @returns Parser implementing JisonParserApi and a Lexer implementing JisonLexerApi.
 */

import { Node } from '../_classes/Node';
import { LinkedList } from '../_structs/LinkedList';
import { DataFollowListTuple } from '../_classes/DataFollowListTuple';

function hexlify (str:string): string {
  return str.split('')
    .map(ch => '0x' + ch.charCodeAt(0).toString(16))
    .join(', ')
}

// To reset
let nodeCounter = 0;

function getNodeCounter(): number {
    nodeCounter++;
    return nodeCounter;
}

let followPosTable: DataFollowListTuple[] = [];
let alphabetList: string[] = [];

function insertInFollowPosTable(keys: LinkedList<number>, elemsForEachKey: LinkedList<number>) {
    for (let i = 0; i < keys.size(); i++) {
        for (let j = 0; j < elemsForEachKey.size(); j++) {
            if(!followPosTable[keys.get(i)! - 1].followList.contains(elemsForEachKey.get(j)!)) {
                followPosTable[keys.get(i)! - 1].followList.appendSorted(elemsForEachKey.get(j)!);
            }
        }
    }
}

function insertInAlphabetList(elem: string) {
    if (!alphabetList.includes(elem)) {
        alphabetList.push(elem);
    }
}


export class TsCalcParser extends JisonParser implements JisonParserApi {
    $?: any;
    symbols_: SymbolsType = {"error":2,"expressions":3,"expr":4,"EOF":5,"term":6,"|":7,"factor":8,"base":9,"*":10,"+":11,"?":12,"(":13,")":14,"EPSILON":15,"CHAR":16,"INVALID":17,"$accept":0,"$end":1};
    terminals_: TerminalsType = {2:"error",5:"EOF",7:"|",10:"*",11:"+",12:"?",13:"(",14:")",15:"EPSILON",16:"CHAR",17:"INVALID"};
    productions_: ProductionsType = [0,[3,2],[3,2],[4,1],[4,3],[6,1],[6,2],[8,1],[8,2],[8,2],[8,2],[9,3],[9,1],[9,1],[9,1]];
    table: Array<StateType>;
    defaultActions: {[key:number]: any} = {11:[2,1],13:[2,2]};

    constructor (yy = {}, lexer = new TsCalcLexer(yy)) {
      super(yy, lexer);

      // shorten static method to just `o` for terse STATE_TABLE
      const $V0=[1,7],$V1=[1,8],$V2=[1,9],$V3=[1,10],$V4=[1,12],$V5=[5,7,14],$V6=[5,7,13,14,15,16,17],$V7=[5,7,10,11,12,13,14,15,16,17];
      const o = JisonParser.expandParseTable;
      this.table = [{2:[1,3],3:1,4:2,6:4,8:5,9:6,13:$V0,15:$V1,16:$V2,17:$V3},{1:[3]},{5:[1,11],7:$V4},{5:[1,13]},o($V5,[2,3],{9:6,8:14,13:$V0,15:$V1,16:$V2,17:$V3}),o($V6,[2,5]),o($V6,[2,7],{10:[1,15],11:[1,16],12:[1,17]}),{4:18,6:4,8:5,9:6,13:$V0,15:$V1,16:$V2,17:$V3},o($V7,[2,12]),o($V7,[2,13]),o($V7,[2,14]),{1:[2,1]},{6:19,8:5,9:6,13:$V0,15:$V1,16:$V2,17:$V3},{1:[2,2]},o($V6,[2,6]),o($V6,[2,8]),o($V6,[2,9]),o($V6,[2,10]),{7:$V4,14:[1,20]},o($V5,[2,4],{9:6,8:14,13:$V0,15:$V1,16:$V2,17:$V3}),o($V7,[2,11])];
    }

    performAction (yytext:string, yyleng:number, yylineno:number, yy:any, yystate:number /* action[1] */, $$:any /* vstack */, _$:any /* lstack */, errors: any): any {
/* this == yyval */
          var $0 = $$.length - 1;
        switch (yystate) {
case 1:
   let thorpeNode = new Node("#", false, getNodeCounter());
            let rootNode = new Node(".", $$[$0-1].isNullable && false);
            thorpeNode.firstPosList.append(thorpeNode.count);
            thorpeNode.lastPosList.append(thorpeNode.count);

            rootNode.leftNode = $$[$0-1];
            rootNode.rightNode = thorpeNode;

            // First pos list
            if(rootNode.leftNode!.isNullable === true) {
                let newList = rootNode.leftNode!.firstPosList.clone();
                newList.addAll(rootNode.rightNode.firstPosList);

                rootNode.firstPosList.addAll(newList);
            } else {
                rootNode.firstPosList.addAll(rootNode.leftNode!.firstPosList);
            }

            // Last pos list
            if(rootNode.rightNode.isNullable === true) {
                let newList = rootNode.leftNode!.lastPosList.clone();
                newList.addAll(rootNode.rightNode.lastPosList);

                rootNode.lastPosList.addAll(newList);
            } else {
                rootNode.lastPosList.addAll(rootNode.rightNode.lastPosList);
            }

            // Insert in followPosTable
            insertInFollowPosTable(
                rootNode.leftNode!.lastPosList,
                rootNode.rightNode.firstPosList
            );


            let trueResponse = { rootNode, followPosTable: [...followPosTable], alphabetList: [...alphabetList] }
            
            nodeCounter = 0;
            followPosTable = [];
            alphabetList = [];
            return trueResponse; 
        
break;
case 2:

          errors.push({
            type: 'syntax',
            message: 'Syntax error in expression',
            location: _$[$0-1]
          });
          return '';
        
break;
case 3: case 5: case 7:
 this.$ = $$[$0]; 
break;
case 4:
 
            this.$ = new Node("|", $$[$0-2].isNullable || $$[$0].isNullable); 
            this.$.leftNode = $$[$0-2]; 
            this.$.rightNode = $$[$0]; 

            // First pos list
            let newList = this.$.leftNode.firstPosList.clone();
            newList.addAll(this.$.rightNode.firstPosList);
            this.$.firstPosList.addAll(newList);

            // Last pos list
            let newList2 = this.$.leftNode.lastPosList.clone();
            newList2.addAll(this.$.rightNode.lastPosList);
            this.$.lastPosList.addAll(newList2);
        
break;
case 6:
 
            this.$ = new Node(".", $$[$0-1].isNullable && $$[$0].isNullable); 
            this.$.leftNode = $$[$0-1]; 
            this.$.rightNode = $$[$0];

            // First pos list
            if(this.$.leftNode.isNullable === true) {
                let newList = this.$.leftNode.firstPosList.clone();
                newList.addAll(this.$.rightNode.firstPosList);

                this.$.firstPosList.addAll(newList);
            } else {
                this.$.firstPosList.addAll(this.$.leftNode.firstPosList);
            }

            // Last pos list
            if(this.$.rightNode.isNullable === true) {
                let newList = this.$.leftNode.lastPosList.clone();
                newList.addAll(this.$.rightNode.lastPosList);

                this.$.lastPosList.addAll(newList);
            } else {
                this.$.lastPosList.addAll(this.$.rightNode.lastPosList);
            }

            // Insert in followPosTable
            insertInFollowPosTable(
                this.$.leftNode.lastPosList,
                this.$.rightNode.firstPosList
            );
        
break;
case 8:
 
            this.$ = new Node("*", true); 
            this.$.leftNode = $$[$0-1]; 
            this.$.firstPosList.addAll($$[$0-1].firstPosList);
            this.$.lastPosList.addAll($$[$0-1].lastPosList);

            insertInFollowPosTable(
                this.$.lastPosList,
                this.$.firstPosList
            );
        
break;
case 9:
 
            this.$ = new Node("+", false); 
            this.$.leftNode = $$[$0-1]; 
            this.$.firstPosList.addAll($$[$0-1].firstPosList);
            this.$.lastPosList.addAll($$[$0-1].lastPosList);

            insertInFollowPosTable(
                this.$.lastPosList,
                this.$.firstPosList
            );
        
break;
case 10:
 
            this.$ = new Node("?", true); 
            this.$.leftNode = $$[$0-1];
            this.$.firstPosList.addAll($$[$0-1].firstPosList);
            this.$.lastPosList.addAll($$[$0-1].lastPosList);
        
break;
case 11:
 this.$ = $$[$0-1]; 
break;
case 12:

            this.$ = new Node($$[$0], true);
        
break;
case 13:
 
            this.$ = new Node($$[$0], false, getNodeCounter());
            this.$.firstPosList.append(this.$.count);
            this.$.lastPosList.append(this.$.count);
            followPosTable.push(new DataFollowListTuple($$[$0]));
            insertInAlphabetList($$[$0]);
        
break;
case 14:
 
          errors.push({
            type: 'lexical',
            message: 'Invalid character: ' + yytext,
            location: _$[$0]
          });
          this.$ = '';
        
break;
        }
    }
}


/* generated by @ts-jison/lexer-generator 0.4.1-alpha.2 */
import { JisonLexer, JisonLexerApi } from '@ts-jison/lexer';

export class TsCalcLexer extends JisonLexer implements JisonLexerApi {
    options: any = {"moduleName":"TsCalc"};
    constructor (yy = {}) {
        super(yy);
    }

    rules: RegExp[] = [
        /^(?:\s+)/,
        /^(?:\*|\u2217)/,
        /^(?:\+)/,
        /^(?:\||\u2223)/,
        /^(?:\?)/,
        /^(?:\()/,
        /^(?:\))/,
        /^(?:\u03b5|\u03f5)/,
        /^(?:[^?\+\*\(\)"|""\u2223""'"\"\\\n\r\t])/,
        /^(?:$)/,
        /^(?:.)/
    ];
    conditions: any = {"INITIAL":{"rules":[0,1,2,3,4,5,6,7,8,9,10],"inclusive":true}}
    performAction (yy:any,yy_:any,$avoiding_name_collisions:any,YY_START:any): any {
          var YYSTATE=YY_START;
        switch($avoiding_name_collisions) {
    case 0:if (yy.trace) yy.trace(`skipping whitespace ${hexlify(yy_.yytext)}`)
      break;
    case 1:return 10
    case 2:return 11
    case 3:return 7
    case 4:return 12
    case 5:return 13
    case 6:return 14
    case 7:return 15
    case 8:return 16
    case 9:return 5
    case 10:return 17
        }
    }
}


